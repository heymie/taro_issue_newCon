'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var taro = require('@tarojs/taro');

var TaroLifeCycles;
(function (TaroLifeCycles) {
    TaroLifeCycles["WillMount"] = "componentWillMount";
    TaroLifeCycles["DidMount"] = "componentDidMount";
    TaroLifeCycles["DidShow"] = "componentDidShow";
    TaroLifeCycles["DidHide"] = "componentDidHide";
    TaroLifeCycles["WillUnmount"] = "componentWillUnmount";
})(TaroLifeCycles || (TaroLifeCycles = {}));
var lifecycleMap = {};
lifecycleMap[TaroLifeCycles.WillMount] = ['created', 'onLoad', 'onLanuch'];
lifecycleMap[TaroLifeCycles.DidMount] = ['onReady', 'ready', 'attached'];
lifecycleMap[TaroLifeCycles.DidShow] = ['onShow'];
lifecycleMap[TaroLifeCycles.DidHide] = ['onHide'];
lifecycleMap[TaroLifeCycles.WillUnmount] = ['detached', 'onUnload'];
var lifecycles = new Set();
for (var key in lifecycleMap) {
    var lifecycle = lifecycleMap[key];
    lifecycle.forEach(function (l) { return lifecycles.add(l); });
}

/**
 * Simple bind, faster than native
 */
function bind(fn /*: Function */, ctx /*: Object */) {
    if (!fn)
        { return false; }
    function boundFn(a) {
        var l /*: number */ = arguments.length;
        return l ? (l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a)) : fn.call(ctx);
    }
    // record original fn length
    boundFn._length = fn.length;
    return boundFn;
}
function isEqual(obj1, obj2) {
    return JSON.stringify(obj1) === JSON.stringify(obj2);
}
function noop() {
    var _ = [], len = arguments.length;
    while ( len-- ) _[ len ] = arguments[ len ];

    //
}
var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
};
function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
        return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
        this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
}

var ARRAYTYPE = '[object Array]';
var OBJECTTYPE = '[object Object]';
var FUNCTIONTYPE = '[object Function]';

function diff (current, pre) {
  var result = {};
  syncKeys(current, pre);
  _diff(current, pre, '', result);
  return result
}

function syncKeys (current, pre) {
  if (current === pre) { return }
  var rootCurrentType = type(current);
  var rootPreType = type(pre);
  if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {
    // if(Object.keys(current).length >= Object.keys(pre).length){
    for (var key in pre) {
      var currentValue = current[key];
      if (currentValue === undefined) {
        current[key] = null;
      } else {
        syncKeys(currentValue, pre[key]);
      }
    }
    // }
  } else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {
    if (current.length >= pre.length) {
      pre.forEach(function (item, index) {
        syncKeys(current[index], item);
      });
    }
  }
}

function _diff (current, pre, path, result) {
  if (current === pre) { return }
  var rootCurrentType = type(current);
  var rootPreType = type(pre);
  if (rootCurrentType == OBJECTTYPE) {
    if (rootPreType != OBJECTTYPE || Object.keys(current).length < Object.keys(pre).length) {
      setResult(result, path, current);
    } else {
      var loop = function ( key ) {
        var currentValue = current[key];
        var preValue = pre[key];
        var currentType = type(currentValue);
        var preType = type(preValue);
        if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {
          if (currentValue != pre[key]) {
            setResult(result, (path == '' ? '' : path + '.') + key, currentValue);
          }
        } else if (currentType == ARRAYTYPE) {
          if (preType != ARRAYTYPE) {
            setResult(result, (path == '' ? '' : path + '.') + key, currentValue);
          } else {
            if (currentValue.length < preValue.length) {
              setResult(result, (path == '' ? '' : path + '.') + key, currentValue);
            } else {
              currentValue.forEach(function (item, index) {
                _diff(item, preValue[index], (path == '' ? '' : path + '.') + key + '[' + index + ']', result);
              });
            }
          }
        } else if (currentType == OBJECTTYPE) {
          if (preType != OBJECTTYPE || Object.keys(currentValue).length < Object.keys(preValue).length) {
            setResult(result, (path == '' ? '' : path + '.') + key, currentValue);
          } else {
            for (var subKey in currentValue) {
              _diff(currentValue[subKey], preValue[subKey], (path == '' ? '' : path + '.') + key + '.' + subKey, result);
            }
          }
        }
      };

      for (var key in current) loop( key );
    }
  } else if (rootCurrentType == ARRAYTYPE) {
    if (rootPreType != ARRAYTYPE) {
      setResult(result, path, current);
    } else {
      if (current.length < pre.length) {
        setResult(result, path, current);
      } else {
        current.forEach(function (item, index) {
          _diff(item, pre[index], path + '[' + index + ']', result);
        });
      }
    }
  } else {
    setResult(result, path, current);
  }
}

function setResult (result, k, v) {
  if (type(v) != FUNCTIONTYPE) {
    result[k] = v;
  }
}

function type (obj) {
  return Object.prototype.toString.call(obj)
}

var json = JSON;

var clone = function (obj) { return json.parse(stringify(obj)); };

function stringify (obj, opts) {
  if (!opts) { opts = {}; }
  if (typeof opts === 'function') { opts = { cmp: opts }; }
  var space = opts.space || '';
  if (typeof space === 'number') { space = Array(space + 1).join(' '); }
  var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
  var replacer = opts.replacer || function (key, value) { return value };

  var cmp = opts.cmp && (function (f) {
    return function (node) {
      return function (a, b) {
        var aobj = { key: a, value: node[a] };
        var bobj = { key: b, value: node[b] };
        return f(aobj, bobj)
      }
    }
  })(opts.cmp);

  var seen = [];
  return (function stringify (parent, key, node, level) {
    var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
    var colonSeparator = space ? ': ' : ':';

    if (node && node.toJSON && typeof node.toJSON === 'function') {
      node = node.toJSON();
    }

    node = replacer.call(parent, key, node);

    if (node === undefined) {
      return
    }
    if (typeof node !== 'object' || node === null) {
      return json.stringify(node)
    }
    if (isArray(node)) {
      var out = [];
      for (var i = 0; i < node.length; i++) {
        var item = stringify(node, i, node[i], level + 1) || json.stringify(null);
        out.push(indent + space + item);
      }
      return '[' + out.join(',') + indent + ']'
    } else {
      if (seen.indexOf(node) !== -1) {
        if (cycles) { return json.stringify('__cycle__') }
        throw new TypeError('Converting circular structure to JSON')
      } else { seen.push(node); }

      var keys = objectKeys(node).sort(cmp && cmp(node));
      var out$1 = [];
      for (var i$1 = 0; i$1 < keys.length; i$1++) {
        var key$1 = keys[i$1];
        var value = stringify(node, key$1, node[key$1], level + 1);

        if (!value) { continue }

        var keyValue = json.stringify(key$1) +
                  colonSeparator +
                  value;

        out$1.push(indent + space + keyValue);
      }
      seen.splice(seen.indexOf(node), 1);
      return '{' + out$1.join(',') + indent + '}'
    }
  })({ '': obj }, '', obj, 0)
}
var isArray = Array.isArray || function (x) {
  return {}.toString.call(x) === '[object Array]'
};

var objectKeys = Object.keys || function (obj) {
  var has = Object.prototype.hasOwnProperty || function () { return true };
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) { keys.push(key); }
  }
  return keys
};

function defineGetter(component, key, getter) {
    Object.defineProperty(component, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            if (getter === 'props') {
                return component.props;
            }
            return Object.assign(Object.assign({}, component.state), component.props);
        }
    });
}
function isFunction(o) {
    return typeof o === 'function';
}
function withWeapp(weappConf) {
    return function (ConnectComponent) {
        var obj;

        var BaseComponent = /*@__PURE__*/(function (ConnectComponent) {
            function BaseComponent(props) {
                var this$1 = this;

                ConnectComponent.call(this, props);
                this._observeProps = [];
                // mixins 可以多次调用生命周期
                this.willMounts = [];
                this.didMounts = [];
                this.didHides = [];
                this.didShows = [];
                this.willUnmounts = [];
                this.safeExecute = function (func) {
                    var args = [], len = arguments.length - 1;
                    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

                    if (isFunction(func))
                        { func.apply(this$1, args); }
                };
                this.selectComponent = function () {
                    var ref;

                    var args = [], len = arguments.length;
                    while ( len-- ) args[ len ] = arguments[ len ];
                    if (this$1.$scope && this$1.$scope.selectComponent) {
                        (ref = this$1.$scope).selectComponent.apply(ref, args);
                    }
                    else {
                        // tslint:disable-next-line: no-console
                        console.error("this.$scope 下没有 selectComponent 方法");
                    }
                };
                this.getRelationNodes = function () {
                    var ref;

                    var args = [], len = arguments.length;
                    while ( len-- ) args[ len ] = arguments[ len ];
                    if (this$1.$scope && this$1.$scope.getRelationNodes) {
                        (ref = this$1.$scope).getRelationNodes.apply(ref, args);
                    }
                    else {
                        // tslint:disable-next-line: no-console
                        console.error("this.$scope 下没有 getRelationNodes 方法");
                    }
                };
                this.setData = function (obj, callback) {
                    var oldState;
                    if (this$1.observers && Object.keys(Object.keys(this$1.observers))) {
                        oldState = clone(this$1.state);
                    }
                    Object.keys(obj).forEach(function (key) {
                        taro.internal_safe_set(this$1.state, key, obj[key]);
                    });
                    taro.setIsUsingDiff(false);
                    this$1.setState(this$1.state, function () {
                        taro.setIsUsingDiff(true);
                        this$1.triggerObservers(this$1.state, oldState);
                        if (callback) {
                            callback.call(this$1);
                        }
                    });
                };
                this.triggerEvent = function (eventName) {
                    var args = [], len = arguments.length - 1;
                    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

                    var func = this$1.props[("on" + (eventName[0].slice(0, 1).toUpperCase()) + (eventName.slice(1)))];
                    if (isFunction(func)) {
                        func.apply(this$1, args.map(function (a) { return ({ detail: a }); }));
                    }
                };
                this.init(weappConf);
                defineGetter(this, 'data', 'state');
                defineGetter(this, 'properties', 'props');
            }

            if ( ConnectComponent ) BaseComponent.__proto__ = ConnectComponent;
            BaseComponent.prototype = Object.create( ConnectComponent && ConnectComponent.prototype );
            BaseComponent.prototype.constructor = BaseComponent;
            BaseComponent.prototype.initProps = function initProps (props) {
                for (var propKey in props) {
                    if (props.hasOwnProperty(propKey)) {
                        var propValue = props[propKey];
                        if (!isFunction(propValue)) {
                            if (propValue.observer) {
                                this._observeProps.push({
                                    name: propKey,
                                    observer: propValue.observer
                                });
                            }
                        }
                        proxy(this, 'props', propKey);
                    }
                }
            };
            BaseComponent.prototype.init = function init (options) {
                for (var confKey in options) {
                    var confValue = options[confKey];
                    switch (confKey) {
                        case 'externalClasses':
                            break;
                        case 'data':
                            this.state = confValue;
                            var keys = Object.keys(this.state);
                            var i = keys.length;
                            while (i--) {
                                var key = keys[i];
                                proxy(this, "state", key);
                            }
                            break;
                        case 'properties':
                            this.initProps(confValue);
                            break;
                        case 'methods':
                            for (var key$1 in confValue) {
                                var method = confValue[key$1];
                                this[key$1] = bind(method, this);
                            }
                            break;
                        case 'behaviors':
                            // this.initMixins(confValue, options);
                            break;
                        case 'lifetimes':
                            for (var key$2 in confValue) {
                                var lifecycle = confValue[key$2];
                                this.initLifeCycles(key$2, lifecycle);
                            }
                            break;
                        default:
                            if (lifecycles.has(confKey)) {
                                var lifecycle$1 = options[confKey];
                                this.initLifeCycles(confKey, lifecycle$1);
                            }
                            else if (isFunction(confValue)) {
                                this[confKey] = bind(confValue, this);
                            }
                            else {
                                this[confKey] = confValue;
                            }
                            break;
                    }
                }
            };
            BaseComponent.prototype.initLifeCycles = function initLifeCycles (lifecycleName, lifecycle) {
                for (var lifecycleKey in lifecycleMap) {
                    var cycleNames = lifecycleMap[lifecycleKey];
                    if (cycleNames.indexOf(lifecycleName) !== -1) {
                        switch (lifecycleKey) {
                            case TaroLifeCycles.DidHide:
                                this.didHides.push(lifecycle);
                                break;
                            case TaroLifeCycles.DidMount:
                                this.didMounts.push(lifecycle);
                                break;
                            case TaroLifeCycles.DidShow:
                                this.didShows.push(lifecycle);
                                break;
                            case TaroLifeCycles.WillMount:
                                this.willMounts.push(lifecycle);
                                break;
                            case TaroLifeCycles.WillUnmount:
                                this.willUnmounts.push(lifecycle);
                                break;
                            default:
                                break;
                        }
                    }
                }
                // mixins 不会覆盖已经设置的生命周期，加入到 this 是为了形如 this.created() 的调用
                if (!isFunction(this[lifecycleName])) {
                    this[lifecycleName] = lifecycle;
                }
            };
            BaseComponent.prototype.executeLifeCycles = function executeLifeCycles (funcs) {
                var ref;

                var args = [], len = arguments.length - 1;
                while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
                for (var i = 0; i < funcs.length; i++) {
                    var func = funcs[i];
                    (ref = this).safeExecute.apply(ref, [ func ].concat( args ));
                }
            };
            BaseComponent.prototype.triggerObservers = function triggerObservers (current, prev) {
                var observers = this.observers;
                if (observers == null) {
                    return;
                }
                if (Object.keys(observers).length === 0) {
                    return;
                }
                var result = diff(current, prev);
                var resultKeys = Object.keys(result);
                if (resultKeys.length === 0) {
                    return;
                }
                for (var observerKey in observers) {
                    var keys = observerKey.split(',').map(function (k) { return k.trim(); });
                    var args = [];
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        for (var j = 0; j < resultKeys.length; j++) {
                            var resultKey = resultKeys[j];
                            if (resultKey.startsWith(key) ||
                                (key.startsWith(resultKey) && key.endsWith(']'))) {
                                args.push(taro.internal_safe_get(current, key));
                            }
                        }
                    }
                    if (args.length) {
                        observers[observerKey].apply(this, args);
                    }
                }
            };
            BaseComponent.prototype.componentWillMount = function componentWillMount () {
                var this$1 = this;

                this._observeProps.forEach(function (ref) {
                    var key = ref.name;
                    var observer = ref.observer;

                    var prop = this$1.props[key];
                    if (typeof observer === 'string') {
                        var ob = this$1[observer];
                        if (isFunction(ob)) {
                            ob.call(this$1, prop, prop, key);
                        }
                    }
                    else if (isFunction(observer)) {
                        observer.call(this$1, prop, prop, key);
                    }
                });
                this.safeExecute.call(this, ConnectComponent.prototype.componentWillMount);
                this.executeLifeCycles(this.willMounts, this.$router.params || {});
            };
            BaseComponent.prototype.componentDidMount = function componentDidMount () {
                this.safeExecute.call(this, ConnectComponent.prototype.componentDidMount);
                this.executeLifeCycles(this.didMounts);
            };
            BaseComponent.prototype.componentWillUnmount = function componentWillUnmount () {
                this.safeExecute.call(this, ConnectComponent.prototype.componentWillUnmount);
                this.executeLifeCycles(this.willUnmounts);
            };
            BaseComponent.prototype.componentDidHide = function componentDidHide () {
                this.safeExecute.call(this, ConnectComponent.prototype.componentDidHide);
                this.executeLifeCycles(this.didHides);
            };
            BaseComponent.prototype.componentDidShow = function componentDidShow () {
                this.safeExecute.call(this, ConnectComponent.prototype.componentDidShow);
                this.executeLifeCycles(this.didShows, this.$router.params || {});
            };
            BaseComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps (nextProps) {
                var this$1 = this;

                this.triggerObservers(nextProps, this.props);
                this._observeProps.forEach(function (ref) {
                    var key = ref.name;
                    var observer = ref.observer;

                    var prop = this$1.props[key];
                    var nextProp = nextProps[key];
                    // 小程序是深比较不同之后才 trigger observer
                    if (!isEqual(prop, nextProp)) {
                        if (typeof observer === 'string') {
                            var ob = this$1[observer];
                            if (isFunction(ob)) {
                                ob.call(this$1, nextProp, prop, key);
                            }
                        }
                        else if (isFunction(observer)) {
                            observer.call(this$1, nextProp, prop, key);
                        }
                    }
                });
                this.safeExecute.call(this, ConnectComponent.prototype.componentWillReceiveProps);
            };

            return BaseComponent;
        }(ConnectComponent));
        var props = weappConf['properties'];
        if (props) {
            for (var propKey in props) {
                var propValue = props[propKey];
                if (propValue != null && !isFunction(propValue)) {
                    if (propValue.value !== undefined) { // 如果是 null 也赋值到 defaultProps
                        BaseComponent.defaultProps = Object.assign(( obj = {}, obj[propKey] = propValue.value, obj ), BaseComponent.defaultProps);
                    }
                }
            }
        }
        var staticOptions = ['externalClasses', 'relations', 'options'];
        staticOptions.forEach(function (option) {
            var value = weappConf[option];
            if (value != null) {
                BaseComponent[option] = value;
            }
        });
        return BaseComponent;
    };
}

exports.default = withWeapp;
//# sourceMappingURL=index.js.map
